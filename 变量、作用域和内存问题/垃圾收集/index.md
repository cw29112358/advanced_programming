### 垃圾回收机制

js具有自动垃圾收集机制，执行环境会负责管理代码执行过程中使用的内存。

原理：找到那些不在继续使用的变量，然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或者代码中预定地收集时间）周期性地执行这一操作。

+ 标记清除：当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为‘进入环境’。从逻辑上来讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应环境，就可能会用到它们。而当其离开环境时，则将其标记为‘离开环境’。

可以用任何方式来标记变量。比如：可以通过反转某个特殊的位来记录一个变量何时进入环境，或者使用一个‘进入环境的’变量列表和一个‘离开环境的’变量列表来跟踪那个变量发生了变化等等

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境在的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清楚工作，销毁那些带标记的值并回收它们所占用的空间。

+ 引用计数：跟踪记录每个值的被引用的次数。当声明了一个变量并将一个引用类型值赋值给该变量时，则这个值的引用次数就是1。如果同一个值又被赋值给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法在访问这个值了，因而就可以将其占用的内存空间回收。这样，当垃圾收集器下次运行时，它就会释放那些引用次数为零的值所占用的内存。

采用引用计数进性收集器回收内存在循环引用中，会有很大问题。

```
function problem() {
  var obj1 = new Object()
  var obj2 = new Object()

  obj1.someProperty = obj2
  obj2.someProperty = obj1 
}
```

在上面的栗子中， obj1 和 obj2 通过各自的属性相互引用；也就是说这两个对象的引用次数都是2。在采用标记清除策略的实现中，由于函数执行后这两个对象都离开了作用域，因此这种相互引用不是问题。但在采用引用计数策略的实现中，当函数执行完毕以后，这两个对象还将继续存在，因为它们的引用次数永远不会是0。假如这个函数被重复调用多次，就会导致大量的内存得不到回收。

> 注意，即使 IE 的 JS 引擎是采用标记清除策略来实现的，但是 COM 对象的垃圾收集器还是采用的引用计数策略实现。换句话说，只要在 IE 中涉及 COM 对象，就会存在循环引用问题。为了避免这样的循环引用问题，最好是在不使用它们的时候手动断开 JS 对象与 DOM 元素之间的连接。在 IE 9 中解决了这个问题。

+ 性能问题

> 主要是 IE 浏览器的垃圾收集机制演变问题，参考 p80

+ 管理内存

分配给 web 浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是处于的安全方面考虑，防止运行 JS 的网页耗尽全部系统内存而导致系统奔溃。内存限制问题不仅会影响给变量分配内存，同时还会影响调用栈以及一个线程中能够同时执行的语句数量。

优化内存的最佳方式就是为执行中的代码保存必要的数据。一旦数据不可用，最好通过将其值设置为 null 来释放其引用--这个作坊叫做解除引用。这个做法适用于大多数的全局变量和全局对象的属性。局部变量会在它们离开执行环境时被自动解除引用。

解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，一边垃圾收集器下次运行时将其回收。